import binascii
from functools import reduce

def string2int(my_str):
    return int(binascii.hexlify(my_str), 16)

def int2string(my_int):
    return binascii.unhexlify(format(my_int, "x").encode("utf-8")).decode("utf-8")


# def factors(n):
#     return set(reduce(list.__add__,
#                 ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)))

# https://rosettacode.org/wiki/Modular_inverse#Python
def extended_gcd(aa, bb):
    lastremainder, remainder = abs(aa), abs(bb)
    x, lastx, y, lasty = 0, 1, 1, 0
    while remainder:
        lastremainder, (quotient, remainder) = remainder, divmod(lastremainder, remainder)
        x, lastx = lastx - quotient * x, x
        y, lasty = lasty - quotient * y, y
    return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1)

# https://rosettacode.org/wiki/Modular_inverse#Python
def modinv(a, m):
    g, x, y = extended_gcd(a, m)
    if g != 1:
        raise ValueError
    return x % m

N = 25601081622800154604549941267957556134455650842506499658603102891643401651348747767414449578328164107622688433747072378842165816256618240895510145167461862482628550794982299239629656890894547227915236009612296432744185205198920264639850870933932377480541689269061625301115683579980881550277340487413315740421970669180712693415647652710030237423848134531688349827849408597551724711356306148798870631200208650058901068544553433340883542197838896836783372668017286824793419377423550379378097828537762044377584560338392966233826760480039964945830050175730610082714576603216528553698653067347469654541732857998113151465751

e =65537

dp = 152244367079401291358716469487584150991338743989392990770913626288139830903544366284978873842165797802924783266589136772176969547853810132758515251384877814239456989641537309467459189296399458554310236664344352802881532047849722063137221142352957646714675083505704164554173755971781242136342727195650051929435

c =12197258568853253547597040581799946041585986603548186383428773143700443084556162229874361765452507412066554533559769888691295815764576474732238999342288173330325352937584949613008563970193717161361539720499836980797409433259876708192396714875184109702115953317136419961350534704241826643935659625518719884048804599520100706583765280609694145787711412815948671377833129126071454424282099361050479569057271974367819833668852729889383791011872438269112628196219820580116434335242272832914188310014441732301910630472073299647433186769498080029754149537819245807726617816718620076398309880611122566595761613531977918779273

# https://medium.com/@nicebowlofsoup/picoctf-2017-weirderrsa-writeup-194b30cb3316.
# Factor N with factordb
l = dp * e - 1 # helps find factor p of n
p = 0 # p value placeholder
for k in range(1, e):
    if l%k == 0:
        p = (l//k + 1) # calculates p value.
        if N%p == 0: # if value is a multiple of p (divides into p with a remainder of 0)
            q = N//p # calculates q value by dividing n by p ( n = p*q ).
            t = (p-1)*(q-1) # calculates totient ( needed to find d exponent )
            print(pow(c,modinv(e,t),N)) # ciphertext, modinv(e,t) = d, modulus.

decrypted =  655335936731130278179451553900281813753288915929351798702432254552777426722411562772879551353158290619593518

a = int2string(decrypted)
print(a)



